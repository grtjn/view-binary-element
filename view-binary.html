<template id="view-binary-template">
  <style>
    .view-binary,
    .view-binary #view-binary-loading,
    .view-binary #view-binary-viewer,
    .view-binary #view-binary-audio,
    .view-binary #view-binary-video,
    .view-binary #view-binary-picture,
    .view-binary #view-binary-object {
      height: 100%;
      width: 100%;
      overflow: auto;
    }
  </style>
  <div class="view-binary">
    <div id="view-binary-loading">
      <slot name="loading">
        Loading... <i class="fa fa-spinner fa-spin"></i>
      </slot>
    </div>
    <div id="view-binary-viewer">
      <audio id="view-binary-audio" controls preload="metadata" src="" title="">
        <slot id="fallback" name="fallback"></slot>
      </audio>
      <video id="view-binary-video" controls preload="metadata" src="" title="" playsinline>
      </video>
      <picture id="view-binary-picture">
        <img src="" alt="">
      </picture>
      <object id="view-binary-object" data="" type="" title="">
      </object>
    </div>
    <div id="view-binary-spacer"></div>
  </div>
</template>

<script>
// Usage:
// <view-binary src="" type="" title="">
//   <a class="btn btn-default" href="" target="_blank" download>Download</a>
// </view-binary>

(function() {
  var functionLogger = {};

  functionLogger.log = true;//Set this to false to disable logging

  /**
   * Gets a function that when called will log information about itself if logging is turned on.
   *
   * @param func The function to add logging to.
   * @param name The name of the function.
   *
   * @return A function that will perform logging and then call the function.
   */
  functionLogger.getLoggableFunction = function(func, name, ns) {
      return function() {
          if (functionLogger.log) {
              var logText = (ns ? (ns + '.') : '') + name + '(';

              for (var i = 0; i < arguments.length; i++) {
                  if (i > 0) {
                      logText += ', ';
                  }
                  logText += arguments[i];
              }
              logText += ');';

              console.log(logText);
          }

          return func.apply(this, arguments);
      }
  };

  /**
   * After this is called, all direct children of the provided namespace object that are
   * functions will log their name as well as the values of the parameters passed in.
   *
   * @param namespaceObject The object whose child functions you'd like to add logging to.
   */
  functionLogger.addLoggingToNamespace = function(namespaceObject, ns){
    if (functionLogger.log) {
      for(var name in namespaceObject){
          var potentialFunction = namespaceObject[name];

          if(Object.prototype.toString.call(potentialFunction) === '[object Function]'){
              namespaceObject[name] = functionLogger.getLoggableFunction(potentialFunction, name, ns);
          }
      }
    }
  };

  // Inspired by https://developers.google.com/web/fundamentals/web-components/

  class ViewBinary extends HTMLElement {

    static get observedAttributes() {
      return ["src", "type", "title"];
    }

    /**
     * The element's constructor is run anytime a new instance is created.
     * Instances are created either by parsing HTML, calling
     * `document.createElement('view-binary')`, or calling `new ViewBinary()`.
     * The construtor is a good place to create shadow DOM, though you should
     * avoid touching any attributes or light DOM children as they may not
     * be available yet.
     */
    constructor() {
      // always call super first
      super();

      // initialize private properties
      this._src = undefined;
      this._type = undefined;
      this._title = undefined;

      // initialize template placeholders
      this.$loading = undefined;
      this.$viewer = undefined;
      this.$audio = undefined;
      this.$video = undefined;
      this.$picture = undefined;
      this.$object = undefined;

      // make sure private methods are properly bound to 'this'
      this._upgradeProperty = this._upgradeProperty.bind(this);
      this._initialize = this._initialize.bind(this);
      this._updateRendering = this._updateRendering.bind(this);

      // trace logging for debug purposes
      if (functionLogger.log) {
        this.connectedCallback = this.connectedCallback.bind(this);
        this.disconnectedCallback = this.disconnectedCallback.bind(this);
        this.adoptedCallback = this.adoptedCallback.bind(this);
        this.attributeChangedCallback = this.attributeChangedCallback.bind(this);
      }

      functionLogger.addLoggingToNamespace(this, 'ViewBinary.this');
    }

    /**
     * `connectedCallback()` fires when the element is inserted into the DOM.
     * It's a good place to set the initial internal state,
     * and install event listeners.
     */
    connectedCallback() {
      // initialize template
      this._initialize();
    }

    /**
     * `disconnectedCallback()` fires when the element is removed from the DOM.
     * It's a good place to do clean up work like releasing references and
     * removing event listeners.
     */
    disconnectedCallback() {
      this._destroy();
    }

    /**
     * `adoptedCallback()`: Invoked when the custom element is moved to a new document.
    */
    adoptedCallback() {
      this._updateRendering();
    }

    /**
     * `attributeChangedCallback()` is called when any of the attributes in the
     * `observedAttributes` array are changed. It's a good place to handle
     * side effects.
     */
    attributeChangedCallback(name, oldValue, newValue) {
      switch (name) {
        case "src" : {
          this._src = newValue;
          break;
        }
        case "type": {
          this._type = newValue;
          break;
        }
        case "title": {
          this._title = newValue;
          break;
        }
      }

      this._updateRendering();
    }

    // Programmatic access to custom element properties
    // Note: this loops back into attributeChangedCallback
    set src(value) {
      if (value)
        this.setAttribute('src', value);
      else
        this.removeAttribute('src');
    }

    get src() {
      return this._src;
    }

    set type(value) {
      if (value)
        this.setAttribute('type', value);
      else
        this.removeAttribute('type');
    }

    get type() {
      return this._type;
    }

    set title(value) {
      if (value)
        this.setAttribute('title', value);
      else
        this.removeAttribute('title');
    }

    get title() {
      return this._title;
    }

    // initialize contents of custom element
    _initialize() {
      // enable Shadow DOM
      this.attachShadow({mode: 'open'});

      // trace logging for debug purposes
      functionLogger.addLoggingToNamespace(this.shadowRoot, 'ViewBinary.this.shadowRoot');

      // Make sure to look inside this html fragement (in case of true html import)
      const doc = document.currentScript.ownerDocument;

      // get and append template
      const template = doc
        .getElementById("view-binary-template")
        .content
        .cloneNode(true);
      this.shadowRoot.appendChild(template);

      // get placeholders
      this.$loading = this.shadowRoot.querySelector("#view-binary-loading");
      this.$viewer = this.shadowRoot.querySelector("#view-binary-viewer");
      this.$audio = this.shadowRoot.querySelector("#view-binary-audio");
      this.$video = this.shadowRoot.querySelector("#view-binary-video");
      this.$picture = this.shadowRoot.querySelector("#view-binary-picture");
      this.$object = this.shadowRoot.querySelector("#view-binary-object");

      // A user may set a property on an _instance_ of an element,
      // before its prototype has been connected to this class.
      // The `_upgradeProperty()` method will check for any instance properties
      // and run them through the proper class setters.
      this._upgradeProperty("src");
      this._upgradeProperty("type");
      this._upgradeProperty("title");

      // initialize rendering
      this._updateRendering();

      // hook up event listeners
      //this.$viewer.addEventListener('click', this.onViewerClick);
    }

    _destroy() {
      // remove event listeners
      //this.$viewer.removeEventListener('click', this.onViewerClick);
    }

    // capture property values from unupgraded instances, and delete them
    // so they do not shadow the custom element's own property setter.
    _upgradeProperty(prop) {
      if (this.hasOwnProperty(prop)) {
        let value = this[prop];
        delete this[prop];
        this[prop] = value;
      }
    }

    // update rendering of placeholders
    _updateRendering() {
      if (this.shadowRoot) {
        if (this._src !== undefined && this._type !== undefined) {
          this.$loading.hidden = true;
          this.$viewer.hidden = false;

          this.$audio.hidden = true;
          this.$video.hidden = true;
          this.$picture.hidden = true;
          this.$object.hidden = true;

          // there can be only one fallback slot, move it around
          var slot = this.shadowRoot.querySelector("#fallback");
          slot.parentNode.removeChild(slot);

          if (this._type.match(/^audio\//)) {
            this.$audio.hidden = false;
            this.$audio.setAttribute("src", this._src);
            this.$audio.setAttribute("title", this._title || "");
            this.$audio.appendChild(slot);
          } else if (this._type.match(/^video\//)) {
            this.$video.hidden = false;
            this.$video.setAttribute("src", this._src);
            this.$video.setAttribute("title", this._title || "");
            this.$video.appendChild(slot);
          } else if (this._type.match(/^image\//)) {
            this.$picture.hidden = false;
            this.$picture.firstElementChild.setAttribute("src", this._src);
            this.$picture.firstElementChild.setAttribute("alt", this._title || "");
            this.$picture.appendChild(slot);
          } else {
            this.$object.hidden = false;
            this.$object.setAttribute("data", this._src);
            this.$object.setAttribute("type", this._type);
            this.$object.setAttribute("title", this._title || "");
            this.$object.appendChild(slot);
          }
        } else {
          this.$loading.hidden = false;
          this.$viewer.hidden = true;
        }
      }
    }

  };

  functionLogger.addLoggingToNamespace(ViewBinary, 'ViewBinary');

  // declare the webcomponent
  window.customElements.define("view-binary", ViewBinary);

})();
</script>
